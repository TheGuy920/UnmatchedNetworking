using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace MemoryPack.Generator;

partial class MemoryPackGenerator
{
    public static void Generate(INamedTypeSymbol typeSymbol, Compilation compilation, IGeneratorContext context)
    {
        // var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);
        //
        // var typeSymbol = semanticModel.GetDeclaredSymbol(syntax, context.CancellationToken);
        // if (typeSymbol == null)
        // {
        //     return;
        // }

        // verify is partial
        // if (!IsPartial(syntax))
        // {
        //     context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MustBePartial, syntax.Identifier.GetLocation(), typeSymbol.Name));
        //     return;
        // }

        // if (IsNested(syntax) && !IsNestedContainingTypesPartial(syntax))
        // {
        //     context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.NestedContainingTypesMustBePartial, syntax.Identifier.GetLocation(), typeSymbol.Name));
        //     return;
        // }

        var reference = new ReferenceSymbols(compilation);

        var unionSymbol = default(INamedTypeSymbol);
        AttributeData? unionFormatterAttr = typeSymbol.GetAttribute(reference.MemoryPackUnionFormatterAttribute);
        if (unionFormatterAttr != null)
        {
            // change symbol
            unionSymbol = unionFormatterAttr.ConstructorArguments[0].Value as INamedTypeSymbol;
            if (unionSymbol == null) return;
        }

        bool unionFormatter = unionSymbol != null;

        var typeMeta = new TypeMeta(typeSymbol, reference);
        if (unionFormatter)
        {
            // replace original symbol
            typeMeta.Symbol = unionSymbol!;
        }

        // if (!unionFormatter && !typeMeta.IsUnion && typeMeta.GenerateType == GenerateType.NoGenerate)
        // {
        //     return;
        // }

        // ReportDiagnostic when validate failed.
        // if (!typeMeta.Validate(syntax, context, unionFormatter))
        // {
        //     return;
        // }

        string fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                                    .Replace("global::", "")
                                    .Replace("<", "_")
                                    .Replace(">", "_");

        var sb = new StringBuilder();

        sb.AppendLine(@"
// <auto-generated/>
#nullable enable
#pragma warning disable CS0108 // hides inherited member
#pragma warning disable CS0162 // Unreachable code
#pragma warning disable CS0164 // This label has not been referenced
#pragma warning disable CS0219 // Variable assigned but never used
#pragma warning disable CS0618 // Type or member is obsolete
#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.
#pragma warning disable CS8601 // Possible null reference assignment
#pragma warning disable CS8602
#pragma warning disable CS8604 // Possible null reference argument for parameter
#pragma warning disable CS8619
#pragma warning disable CS8620
#pragma warning disable CS8631 // The type cannot be used as type parameter in the generic type or method
#pragma warning disable CS8765 // Nullability of type of parameter
#pragma warning disable CS9074 // The 'scoped' modifier of parameter doesn't match overridden or implemented member
#pragma warning disable CA1050 // Declare types in namespaces.

using System;
using MemoryPack;
");

        INamespaceSymbol? ns = typeMeta.Symbol.ContainingNamespace;
        if (!ns.IsGlobalNamespace)
        {
            if (context.IsCSharp10OrGreater())
            {
                sb.AppendLine($"namespace {ns};");
            }
            else
            {
                sb.AppendLine($"namespace {ns} {{");
            }
        }

        sb.AppendLine();

        // Write document comment as remarks
        if (typeMeta.GenerateType is GenerateType.Object or GenerateType.VersionTolerant or GenerateType.CircularReference)
        {
            BuildDebugInfo(sb, typeMeta, true);
        }

        // emit type info
        if (unionFormatter)
        {
            typeMeta.EmitUnionFormatterTemplate(sb, context, typeSymbol);
        }
        else
        {
            typeMeta.Emit(sb, context);
        }

        if (!ns.IsGlobalNamespace && !context.IsCSharp10OrGreater())
        {
            sb.AppendLine("}");
        }

        var code = sb.ToString();
        context.AddSource($"{fullType}.MemoryPackFormatter.g.cs", code);
    }

    private static bool IsPartial(TypeDeclarationSyntax typeDeclaration)
    {
        return typeDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
    }

    private static bool IsNestedContainingTypesPartial(TypeDeclarationSyntax typeDeclaration)
    {
        if (typeDeclaration.Parent is TypeDeclarationSyntax parentTypeDeclaration)
        {
            if (!IsPartial(parentTypeDeclaration))
                return false;

            return IsNestedContainingTypesPartial(parentTypeDeclaration);
        }

        return true;
    }

    private static bool IsNested(TypeDeclarationSyntax typeDeclaration)
        => typeDeclaration.Parent is TypeDeclarationSyntax;

    private static void BuildDebugInfo(StringBuilder sb, TypeMeta type, bool xmlDocument)
    {
        string WithEscape(ISymbol symbol)
        {
            string str = symbol.FullyQualifiedToString().Replace("global::", "");
            if (xmlDocument)
            {
                return str.Replace("<", "&lt;").Replace(">", "&gt;");
            }

            return str;
        }

        if (!xmlDocument)
        {
            if (type.IsUnmanagedType)
            {
                sb.Append("GenerateType unmanaged ");
            }
            else
            {
                sb.Append("GenerateType " + type.GenerateType + " ");
            }

            sb.AppendLine(WithEscape(type.Symbol));
            sb.AppendLine("---");
        }
        else
        {
            sb.AppendLine("/// <remarks>");
            if (type.IsUnmanagedType)
            {
                sb.AppendLine("/// MemoryPack GenerateType: unmanaged<br/>");
            }
            else
            {
                sb.AppendLine("/// MemoryPack GenerateType: " + type.GenerateType + "<br/>");
            }

            sb.AppendLine("/// <code>");
        }

        foreach (MemberMeta item in type.Members)
        {
            if (xmlDocument)
            {
                sb.Append("/// <b>");
            }

            sb.Append(WithEscape(item.MemberType));
            if (xmlDocument)
            {
                sb.Append("</b>");
            }

            sb.Append(" ");
            sb.Append(item.Name);

            if (xmlDocument)
            {
                sb.AppendLine("<br/>");
            }
            else
            {
                sb.AppendLine();
            }
        }

        if (xmlDocument)
        {
            sb.AppendLine("/// </code>");
            sb.AppendLine("/// </remarks>");
        }
    }
}

public partial class TypeMeta
{
    public void Emit(StringBuilder writer, IGeneratorContext context)
    {
        if (this.IsUnion)
        {
            writer.AppendLine(this.EmitUnionTemplate(context));
            return;
        }

        if (this.GenerateType == GenerateType.Collection)
        {
            writer.AppendLine(this.EmitGenericCollectionTemplate(context));
            return;
        }

        var serializeBody = "";
        var deserializeBody = "";
        if (this.IsUnmanagedType)
        {
            serializeBody = """        writer.WriteUnmanaged(value);""";
            deserializeBody = """        reader.ReadUnmanaged(out value);""";
        }
        else
        {
            MemberMeta[] originalMembers = this.Members;
            if (this.GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference)
            {
                // for emit time, replace padded empty
                if (this.Members.Length != 0)
                {
                    int maxOrder = this.Members.Max(x => x.Order);
                    var tempMembers = new MemberMeta[maxOrder + 1];
                    for (var i = 0; i <= maxOrder; i++)
                    {
                        tempMembers[i] = this.Members.FirstOrDefault(x => x.Order == i) ?? MemberMeta.CreateEmpty(i);
                    }

                    this.Members = tempMembers;
                }
            }

            serializeBody = this.EmitSerializeBody(context.IsForUnity);
            deserializeBody = this.EmitDeserializeBody();

            this.Members = originalMembers;
        }

        string classOrStructOrRecord = (this.IsRecord, this.IsValueType) switch
        {
            (true, true) => "record struct",
            (true, false) => "record",
            (false, true) => "struct",
            (false, false) => "class"
        };

        var containingTypeDeclarations = new List<string>();
        INamedTypeSymbol? containingType = this.Symbol.ContainingType;
        while (containingType is not null)
        {
            containingTypeDeclarations.Add((containingType.IsRecord, containingType.IsValueType) switch
            {
                (true, true) => $"partial record struct {containingType.Name}",
                (true, false) => $"partial record {containingType.Name}",
                (false, true) => $"partial struct {containingType.Name}",
                (false, false) => $"partial class {containingType.Name}"
            });
            containingType = containingType.ContainingType;
        }

        containingTypeDeclarations.Reverse();

        string nullable = this.IsValueType ? "" : "?";

        string staticRegisterFormatterMethod, staticMemoryPackableMethod, scopedRef, constraint, registerBody, registerT;
        var fixedSizeInterface = "";
        var fixedSizeMethod = "";
        scopedRef = context.IsCSharp11OrGreater()
            ? "scoped ref"
            : "ref";
        if (!context.IsNet7OrGreater)
        {
            staticRegisterFormatterMethod = "public static void ";
            staticMemoryPackableMethod = "public static void ";
            constraint = context.IsForUnity ? "" : "where TBufferWriter : class, System.Buffers.IBufferWriter<byte>";
            registerBody = $"global::MemoryPack.MemoryPackFormatterProvider.Register(new {this.Symbol.Name}Formatter());";
            registerT = "RegisterFormatter();";
        }
        else
        {
            staticRegisterFormatterMethod = "static void IMemoryPackFormatterRegister.";
            staticMemoryPackableMethod = $"static void IMemoryPackable<{this.TypeName}>.";
            constraint = "";
            registerBody = $"global::MemoryPack.MemoryPackFormatterProvider.Register(new global::MemoryPack.Formatters.MemoryPackableFormatter<{this.TypeName}>());";
            registerT = $"global::MemoryPack.MemoryPackFormatterProvider.Register<{this.TypeName}>();";

            // similar as VersionTolerantOptimized but not includes String, Array
            var fixedSize = false;
            if (this.Members.All(x => x.Kind is MemberKind.Unmanaged or MemberKind.Enum or MemberKind.UnmanagedNullable or MemberKind.Blank))
            {
                fixedSize = true;
            }

            int callbackCount = new[] { this.OnSerializing, this.OnSerialized, this.OnDeserialized, this.OnDeserializing }.Select(x => x.Length).Sum();
            if (fixedSize && this.GenerateType == GenerateType.Object && !this.IsValueType && callbackCount == 0)
            {
                string sizeOf = string.Join(" + ", this.Members.Select(x => $"System.Runtime.CompilerServices.Unsafe.SizeOf<{x.MemberType.FullyQualifiedToString()}>()"));
                string headerPlus = this.Members.Length == 0 ? "1" : "1 + ";
                fixedSizeInterface = ", global::MemoryPack.IFixedSizeMemoryPackable";
                fixedSizeMethod = $$"""

                                        [global::MemoryPack.Internal.Preserve]
                                        static int global::MemoryPack.IFixedSizeMemoryPackable.Size => {{headerPlus}}{{sizeOf}};

                                    """;
            }
        }

        string serializeMethodSignarture = context.IsForUnity
            ? "Serialize(ref MemoryPackWriter"
            : "Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter>";

        foreach (string? declaration in containingTypeDeclarations)
        {
            writer.AppendLine(declaration);
            writer.AppendLine("{");
        }

        writer.AppendLine($$"""
                            partial {{classOrStructOrRecord}} {{this.TypeName}} : IMemoryPackable<{{this.TypeName}}>{{fixedSizeInterface}}
                            {
                            {{this.EmitCustomFormatters()}}
                                static partial void StaticConstructor();

                                static {{this.Symbol.Name}}()
                                {
                                    {{registerT}}
                                    StaticConstructor();
                                }
                            {{fixedSizeMethod}}
                                [global::MemoryPack.Internal.Preserve]
                                {{staticRegisterFormatterMethod}}RegisterFormatter()
                                {
                                    if (!global::MemoryPack.MemoryPackFormatterProvider.IsRegistered<{{this.TypeName}}>())
                                    {
                                        {{registerBody}}
                                    }
                                    if (!global::MemoryPack.MemoryPackFormatterProvider.IsRegistered<{{this.TypeName}}[]>())
                                    {
                                        global::MemoryPack.MemoryPackFormatterProvider.Register(new global::MemoryPack.Formatters.ArrayFormatter<{{this.TypeName}}>());
                                    }
                            {{this.EmitAdditionalRegisterFormatter("        ", context)}}
                                }

                                [global::MemoryPack.Internal.Preserve]
                                {{staticMemoryPackableMethod}}{{serializeMethodSignarture}} writer, {{scopedRef}} {{this.TypeName}}{{nullable}} value) {{constraint}}
                                {
                            {{this.OnSerializing.Select(x => "        " + x.Emit()).NewLine()}}
                            {{serializeBody}}
                                END:
                            {{this.OnSerialized.Select(x => "        " + x.Emit()).NewLine()}}
                                    return;
                                }

                                [global::MemoryPack.Internal.Preserve]
                                {{staticMemoryPackableMethod}}Deserialize(ref MemoryPackReader reader, {{scopedRef}} {{this.TypeName}}{{nullable}} value)
                                {
                            {{this.OnDeserializing.Select(x => "        " + x.Emit()).NewLine()}}
                            {{deserializeBody}}
                                END:
                            {{this.OnDeserialized.Select(x => "        " + x.Emit()).NewLine()}}
                                    return;
                                }
                            }
                            """);

        if (!context.IsNet7OrGreater)
        {
            // add formatter(can not use MemoryPackableFormatter)

            var code = $$"""
                         partial {{classOrStructOrRecord}} {{this.TypeName}}
                         {
                             [global::MemoryPack.Internal.Preserve]
                             sealed class {{this.Symbol.Name}}Formatter : MemoryPackFormatter<{{this.TypeName}}>
                             {
                                 [global::MemoryPack.Internal.Preserve]
                                 public override void {{serializeMethodSignarture}} writer,  {{scopedRef}} {{this.TypeName}} value)
                                 {
                                     {{this.TypeName}}.Serialize(ref writer, ref value);
                                 }

                                 [global::MemoryPack.Internal.Preserve]
                                 public override void Deserialize(ref MemoryPackReader reader, {{scopedRef}} {{this.TypeName}} value)
                                 {
                                     {{this.TypeName}}.Deserialize(ref reader, ref value);
                                 }
                             }
                         }
                         """;
            writer.AppendLine(code);
        }

        for (var i = 0; i < containingTypeDeclarations.Count; ++i)
        {
            writer.AppendLine("}");
        }
    }

    private string EmitDeserializeBody()
    {
        int count = this.Members.Length;

        bool isVersionTolerant = this.GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference;
        var readBeginBody = "";
        var readEndBody = "";
        var commentOutInvalidBody = "";
        var circularReferenceBody = "";
        var circularReferenceBody2 = "";

        if (isVersionTolerant)
        {
            readBeginBody = """
                                    Span<int> deltas = stackalloc int[count];
                                    for (int i = 0; i < count; i++)
                                    {
                                        deltas[i] = reader.ReadVarIntInt32();
                                    }
                            """;

            readEndBody = """
                                  if (count == readCount) goto END;

                                  for (int i = readCount; i < count; i++)
                                  {
                                      reader.Advance(deltas[i]);
                                  }
                          """;

            commentOutInvalidBody = "// ";
        }

        if (this.GenerateType == GenerateType.CircularReference)
        {
            circularReferenceBody = $$"""
                                              uint id;
                                              if (count == MemoryPackCode.ReferenceId)
                                              {
                                                  id = reader.ReadVarIntUInt32();
                                                  value = ({{this.TypeName}})reader.OptionalState.GetObjectReference(id);
                                                  goto END;
                                              }
                                      """;

            circularReferenceBody2 = $$"""
                                               id = reader.ReadVarIntUInt32();
                                               if (value == null)
                                               {
                                                   value = new {{this.TypeName}}();
                                               }
                                               reader.OptionalState.AddObjectReference(id, value);
                                       """;
        }

        return $$"""
                         if (!reader.TryReadObjectHeader(out var count))
                         {
                             value = default!;
                             goto END;
                         }
                 {{circularReferenceBody}}
                 {{readBeginBody}}
                 {{circularReferenceBody2}}
                 {{this.Members.Where(x => x.Symbol != null).Select(x => $"        {x.MemberType.FullyQualifiedToString()} __{x.Name};").NewLine()}}

                         {{(!isVersionTolerant ? "" : "var readCount = " + count + ";")}}
                         if (count == {{count}})
                         {
                             {{(this.IsValueType ? "" : "if (value == null)")}}
                             {
                 {{this.EmitDeserializeMembers(this.Members, "                ")}}

                                 goto NEW;
                             }
                 {{(this.IsValueType ? "#if false" : "            else")}}
                             {
                 {{this.Members.Where(x => x.Symbol != null).Select(x => $"                __{x.Name} = value.@{x.Name};").NewLine()}}

                 {{this.Members.Select(x => "                " + x.EmitReadRefDeserialize(x.Order, this.GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference)).NewLine()}}

                                 goto SET;
                             }
                 {{(this.IsValueType ? "#endif" : "")}}
                         }
                         {{commentOutInvalidBody}}else if (count > {{count}})
                         {{commentOutInvalidBody}}{
                             {{commentOutInvalidBody}}MemoryPackSerializationException.ThrowInvalidPropertyCount(typeof({{this.TypeName}}), {{count}}, count);
                             {{commentOutInvalidBody}}goto READ_END;
                         {{commentOutInvalidBody}}}
                         else
                         {
                             {{(this.IsValueType ? "" : "if (value == null)")}}
                             {
                 {{this.Members.Where(x => x.Symbol != null).Select(x => $"               __{x.Name} = default!;").NewLine()}}
                             }
                 {{(this.IsValueType ? "#if false" : "            else")}}
                             {
                 {{this.Members.Where(x => x.Symbol != null).Select(x => $"               __{x.Name} = value.@{x.Name};").NewLine()}}
                             }
                 {{(this.IsValueType ? "#endif" : "")}}

                             if (count == 0) goto SKIP_READ;
                 {{this.Members.Select((x, i) => "            " + x.EmitReadRefDeserialize(x.Order, this.GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference) + $" if (count == {i + 1}) goto SKIP_READ;").NewLine()}}

                     SKIP_READ:
                             {{(this.IsValueType ? "" : "if (value == null)")}}
                             {
                                 goto NEW;
                             }
                 {{(this.IsValueType ? "#if false" : "            else")}}
                             {
                                 goto SET;
                             }
                 {{(this.IsValueType ? "#endif" : "")}}
                         }

                     SET:
                         {{(!this.IsUseEmptyConstructor ? "goto NEW;" : "")}}
                 {{this.Members.Where(x => x.IsAssignable).Select(x => $"        {(this.IsUseEmptyConstructor ? "" : "// ")}value.@{x.Name} = __{x.Name};").NewLine()}}
                         goto READ_END;

                     NEW:
                         value = {{this.EmitConstructor()}}
                         {
                 {{this.EmitDeserializeConstruction("            ")}}
                         };
                 {{this.EmitDeserializeConstructionWithBranching("        ")}}
                     READ_END:
                 {{readEndBody}}
                 """;
    }

    private string EmitAdditionalRegisterFormatter(string indent, IGeneratorContext context)
    {
        var collector = new TypeCollector();
        collector.Visit(this, false);

        (ITypeSymbol x, string?)[] types = collector.GetTypes()
                                                    .Select(x => (x, this.reference.KnownTypes.GetNonDefaultFormatterName(x)))
                                                    .Where(x => x.Item2 != null)
                                                    .Where(x =>
                                                    {
                                                        if (!context.IsNet7OrGreater)
                                                        {
                                                            if (x.Item2!.StartsWith("global::MemoryPack.Formatters.InterfaceReadOnlySetFormatter"))
                                                            {
                                                                return false;
                                                            }

                                                            if (x.Item2!.StartsWith("global::MemoryPack.Formatters.PriorityQueueFormatter"))
                                                            {
                                                                return false;
                                                            }
                                                        }

                                                        return true;
                                                    })
                                                    .ToArray();

        if (types.Length == 0) return "";

        var sb = new StringBuilder();
        foreach ((ITypeSymbol symbol, string? formatter) in types)
        {
            sb.AppendLine($"{indent}if (!global::MemoryPack.MemoryPackFormatterProvider.IsRegistered<{symbol.FullyQualifiedToString()}>())");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    global::MemoryPack.MemoryPackFormatterProvider.Register(new {formatter}());");
            sb.AppendLine($"{indent}}}");
        }

        return sb.ToString();
    }

    private string EmitCustomFormatters()
    {
        var sb = new StringBuilder();
        foreach (MemberMeta? item in this.Members.Where(x => x.Kind == MemberKind.CustomFormatter))
        {
            string fieldOrProp = item.IsField ? "Field" : "Property";

            sb.AppendLine(
                $"    static readonly {item.CustomFormatterName} __{item.Name}Formatter = System.Reflection.CustomAttributeExtensions.GetCustomAttribute<{item.CustomFormatter!.FullyQualifiedToString()}>(typeof({this.Symbol.FullyQualifiedToString()}).Get{fieldOrProp}(\"{item.Name}\", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)).GetFormatter();");
        }

        return sb.ToString();
    }

    private string EmitSerializeBody(bool isForUnity)
    {
        if (this.GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference)
        {
            if (this.Members.All(x => x.Kind is MemberKind.Unmanaged or MemberKind.String or MemberKind.Enum or MemberKind.UnmanagedArray or MemberKind.UnmanagedNullable or MemberKind.Blank))
            {
                return this.EmitVersionTorelantSerializeBodyOptimized(isForUnity);
            }

            return this.EmitVersionTorelantSerializeBody(isForUnity);
        }

        return $"{(!this.IsValueType ? """
                                               if (value == null)
                                               {
                                                   writer.WriteNullObjectHeader();
                                                   goto END;
                                               }
                                       """ : "")}\n\n{this.EmitSerializeMembers(this.Members, "        ", false, true)}";
    }

    private string EmitVersionTorelantSerializeBody(bool isForUnity)
    {
        string newTempWriter = isForUnity
            ? "new MemoryPackWriter(ref System.Runtime.CompilerServices.Unsafe.As<global::MemoryPack.Internal.ReusableLinkedArrayBufferWriter, System.Buffers.IBufferWriter<byte>>(ref tempBuffer), writer.OptionalState)"
            : "new MemoryPackWriter<global::MemoryPack.Internal.ReusableLinkedArrayBufferWriter>(ref tempBuffer, writer.OptionalState)";

        var checkCircularReference = "";
        if (this.GenerateType == GenerateType.CircularReference)
        {
            checkCircularReference = """
                                             var (existsReference, id) = writer.OptionalState.GetOrAddReference(value);
                                             if (existsReference)
                                             {
                                                 writer.WriteObjectReferenceId(id);
                                                 goto END;
                                             }
                                     """;
        }

        return $"{(!this.IsValueType ? """
                                               if (value == null)
                                               {
                                                   writer.WriteNullObjectHeader();
                                                   goto END;
                                               }
                                       """ : "")}\n{checkCircularReference}\n        var tempBuffer = global::MemoryPack.Internal.ReusableLinkedArrayBufferWriterPool.Rent();\n        try\n        {{\n            Span<int> offsets = stackalloc int[{this.Members.Length}];\n            var tempWriter = {newTempWriter};\n\n{this.EmitSerializeMembers(this.Members, "            ", true, false)}\n\n            tempWriter.Flush();\n\n            writer.WriteObjectHeader({this.Members.Length});\n            for (int i = 0; i < {this.Members.Length}; i++)\n            {{\n                int delta;\n                if (i == 0)\n                {{\n                    delta = offsets[i];\n                }}\n                else\n                {{\n                    delta = offsets[i] - offsets[i - 1];\n                }}\n                writer.WriteVarInt(delta);\n            }}\n            {(this.GenerateType == GenerateType.CircularReference ? "writer.WriteVarInt(id);" : "")}\n            tempBuffer.WriteToAndReset(ref writer);\n        }}\n        finally\n        {{\n            global::MemoryPack.Internal.ReusableLinkedArrayBufferWriterPool.Return(tempBuffer);\n        }}";
    }

    // Optimized is all member is fixed size
    private string EmitVersionTorelantSerializeBodyOptimized(bool isForUnity)
    {
        static string EmitLengthHeader(MemberMeta[] members)
        {
            var sb = new StringBuilder();
            foreach (MemberMeta item in members)
            {
                sb.AppendLine("        " + item.EmitVarIntLength());
            }

            return sb.ToString();
        }

        var checkCircularReference = "";
        if (this.GenerateType == GenerateType.CircularReference)
        {
            checkCircularReference = """
                                             var (existsReference, id) = writer.OptionalState.GetOrAddReference(value);
                                             if (existsReference)
                                             {
                                                 writer.WriteObjectReferenceId(id);
                                                 goto END;
                                             }
                                     """;
        }

        return $"{(!this.IsValueType ? """
                                               if (value == null)
                                               {
                                                   writer.WriteNullObjectHeader();
                                                   goto END;
                                               }
                                       """ : "")}\n{checkCircularReference}\n        writer.WriteObjectHeader({this.Members.Length});\n{EmitLengthHeader(this.Members)}\n        {(this.GenerateType == GenerateType.CircularReference ? "writer.WriteVarInt(id);" : "")}\n{this.EmitSerializeMembers(this.Members, "        ", false, false)}";
    }

    // toTempWriter is VersionTolerant
    public string EmitSerializeMembers(MemberMeta[] members, string indent, bool toTempWriter, bool writeObjectHeader)
    {
        // members is guranteed writable.
        if (members.Length == 0 && writeObjectHeader)
        {
            return $"{indent}writer.WriteObjectHeader(0);";
        }

        string writer = toTempWriter ? "tempWriter" : "writer";

        var sb = new StringBuilder();
        for (var i = 0; i < members.Length; i++)
        {
            if (!(members[i].Kind is MemberKind.Unmanaged or MemberKind.Enum or MemberKind.UnmanagedNullable) || toTempWriter)
            {
                sb.Append(indent);
                if (i == 0 && writeObjectHeader)
                {
                    sb.AppendLine($"{writer}.WriteObjectHeader({this.Members.Length});");
                    sb.Append(indent);
                }

                sb.Append(members[i].EmitSerialize(writer));
                if (toTempWriter)
                {
                    sb.AppendLine($" offsets[{i}] = tempWriter.WrittenCount;");
                }
                else
                {
                    sb.AppendLine();
                }

                continue;
            }

            // search optimization
            int optimizeFrom = i;
            int optimizeTo = i;
            int limit = Math.Min(members.Length, i + 15);
            var dangerous = "";
            for (int j = i; j < limit; j++)
            {
                if (members[j].Kind is MemberKind.Unmanaged or MemberKind.Enum or MemberKind.UnmanagedNullable)
                {
                    if (members[j].Kind is MemberKind.UnmanagedNullable)
                    {
                        dangerous = "Dangerous";
                    }

                    optimizeTo = j;
                }
                else
                {
                    break;
                }
            }

            // write method
            sb.Append(indent);
            if (optimizeFrom == 0 && writeObjectHeader)
            {
                sb.Append($"{writer}.{dangerous}WriteUnmanagedWithObjectHeader(");
                sb.Append(members.Length);
                sb.Append(", ");
            }
            else
            {
                sb.Append($"{writer}.{dangerous}WriteUnmanaged(");
            }

            for (int index = optimizeFrom; index <= optimizeTo; index++)
            {
                if (index != i)
                {
                    sb.Append(", ");
                }

                sb.Append("value.@");
                sb.Append(members[index].Name);
            }

            sb.Append(");");

            if (toTempWriter)
            {
                sb.AppendLine($" offsets[{i}] = tempWriter.WrittenCount;");
            }
            else
            {
                sb.AppendLine();
            }

            i = optimizeTo;
        }

        return sb.ToString();
    }

    // for optimize, can use same count, value == null.
    public string EmitDeserializeMembers(MemberMeta[] members, string indent)
    {
        // {{Members.Select(x => "                " + x.EmitReadToDeserialize()).NewLine()}}
        var sb = new StringBuilder();
        for (var i = 0; i < members.Length; i++)
        {
            if (!(members[i].Kind is MemberKind.Unmanaged or MemberKind.Enum or MemberKind.UnmanagedNullable) || this.GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference)
            {
                sb.Append(indent);
                sb.AppendLine(members[i].EmitReadToDeserialize(i, this.GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference));
                continue;
            }

            // search optimization
            int optimizeFrom = i;
            int optimizeTo = i;
            int limit = Math.Min(members.Length, i + 15);
            var dangerous = "";
            for (int j = i; j < limit; j++)
            {
                if (members[j].Kind is MemberKind.Unmanaged or MemberKind.Enum or MemberKind.UnmanagedNullable)
                {
                    if (members[j].Kind is MemberKind.UnmanagedNullable)
                    {
                        dangerous = "Dangerous";
                    }

                    optimizeTo = j;
                }
                else
                {
                    break;
                }
            }

            // write read method
            sb.Append(indent);
            sb.Append($"reader.{dangerous}ReadUnmanaged(");

            for (int index = optimizeFrom; index <= optimizeTo; index++)
            {
                if (index != i)
                {
                    sb.Append(", ");
                }

                sb.Append("out __");
                sb.Append(members[index].Name);
            }

            sb.AppendLine(");");

            i = optimizeTo;
        }

        return sb.ToString();
    }

    private string EmitConstructor()
    {
        // no need `;` because after using object initializer
        if (this.Constructor == null || this.Constructor.Parameters.Length == 0)
        {
            return $"new {this.TypeName}()";
        }

        Dictionary<string?, string> nameDict = this.Members.Where(x => x.IsConstructorParameter).ToDictionary(x => x.ConstructorParameterName, x => x.Name, StringComparer.OrdinalIgnoreCase);
        IEnumerable<string?> parameters = this.Constructor.Parameters
                                              .Select(x =>
                                              {
                                                  if (nameDict.TryGetValue(x.Name, out string? name))
                                                  {
                                                      return $"__{name}";
                                                  }

                                                  return null; // invalid, validated.
                                              })
                                              .Where(x => x != null);

        return $"new {this.TypeName}({string.Join(", ", parameters)})";
    }

    private string EmitDeserializeConstruction(string indent)
    {
        // all value is deserialized, __Name is exsits.
        return string.Join("," + "\n", this.Members
                                           .Where(x => x is { IsSettable: true, IsConstructorParameter: false, SuppressDefaultInitialization: false })
                                           .Select(x => $"{indent}@{x.Name} = __{x.Name}"));
    }

    private string EmitDeserializeConstructionWithBranching(string indent)
    {
        IEnumerable<(MemberMeta x, int i)> members = this.Members
                                                         .Select((x, i) => (x, i))
                                                         .Where(v => v.x.SuppressDefaultInitialization);

        IEnumerable<string> lines = this.GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference
            ? members.Select(v => $"{indent}if (deltas.Length > {v.i} && deltas[{v.i}] != 0) value.@{v.x.Name} = __{v.x.Name};")
            : members.Select(v => $"{indent}if ({v.i + 1} <= count) value.@{v.x.Name} = __{v.x.Name};");

        return lines.NewLine();
    }

    private string EmitUnionTemplate(IGeneratorContext context)
    {
        string classOrInterfaceOrRecord = this.IsRecord ? "record" : this.Symbol.TypeKind == TypeKind.Interface ? "interface" : "class";

        string staticRegisterFormatterMethod = context.IsNet7OrGreater
            ? "static void IMemoryPackFormatterRegister."
            : "public static void ";
        string register = context.IsNet7OrGreater
            ? $"global::MemoryPack.MemoryPackFormatterProvider.Register<{this.TypeName}>();"
            : "RegisterFormatter();";
        string scopedRef = context.IsCSharp11OrGreater()
            ? "scoped ref"
            : "ref";
        string serializeMethodSignarture = context.IsForUnity
            ? "Serialize(ref MemoryPackWriter"
            : "Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter>";

        var code = $$"""

                     partial {{classOrInterfaceOrRecord}} {{this.TypeName}} : IMemoryPackFormatterRegister
                     {
                         static partial void StaticConstructor();

                         static {{this.Symbol.Name}}()
                         {
                             {{register}}
                             StaticConstructor();
                         }

                         [global::MemoryPack.Internal.Preserve]
                         {{staticRegisterFormatterMethod}}RegisterFormatter()
                         {
                             if (!global::MemoryPack.MemoryPackFormatterProvider.IsRegistered<{{this.TypeName}}>())
                             {
                                 global::MemoryPack.MemoryPackFormatterProvider.Register(new {{this.Symbol.Name}}Formatter());
                             }
                             if (!global::MemoryPack.MemoryPackFormatterProvider.IsRegistered<{{this.TypeName}}[]>())
                             {
                                 global::MemoryPack.MemoryPackFormatterProvider.Register(new global::MemoryPack.Formatters.ArrayFormatter<{{this.TypeName}}>());
                             }
                         }

                         [global::MemoryPack.Internal.Preserve]
                         sealed class {{this.Symbol.Name}}Formatter : MemoryPackFormatter<{{this.TypeName}}>
                         {
                     {{this.EmitUnionTypeToTagField()}}

                             [global::MemoryPack.Internal.Preserve]
                             public override void {{serializeMethodSignarture}} writer, {{scopedRef}} {{this.TypeName}}? value)
                             {
                     {{this.OnSerializing.Select(x => "            " + x.Emit()).NewLine()}}
                     {{this.EmitUnionSerializeBody()}}
                     {{this.OnSerialized.Select(x => "            " + x.Emit()).NewLine()}}
                             }

                             [global::MemoryPack.Internal.Preserve]
                             public override void Deserialize(ref MemoryPackReader reader, {{scopedRef}} {{this.TypeName}}? value)
                             {
                     {{this.OnDeserializing.Select(x => "            " + x.Emit()).NewLine()}}
                     {{this.EmitUnionDeserializeBody()}}
                     {{this.OnDeserialized.Select(x => "            " + x.Emit()).NewLine()}}
                             }
                         }
                     }
                     """;

        return code;
    }

    public void EmitUnionFormatterTemplate(StringBuilder writer, IGeneratorContext context, INamedTypeSymbol formatterSymbol)
    {
        string scopedRef = context.IsCSharp11OrGreater()
            ? "scoped ref"
            : "ref";
        string serializeMethodSignarture = context.IsForUnity
            ? "Serialize(ref MemoryPackWriter"
            : "Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter>";

        string registerFormatterCode;
        if (!this.Symbol.IsGenericType || !this.Symbol.IsUnboundGenericType)
        {
            registerFormatterCode = $$"""
                                              if (!global::MemoryPack.MemoryPackFormatterProvider.IsRegistered<{{this.Symbol.FullyQualifiedToString()}}>())
                                              {
                                                  global::MemoryPack.MemoryPackFormatterProvider.Register(new {{this.TypeName}}());
                                              }
                                      """;
        }
        else
        {
            registerFormatterCode = $$"""
                                              global::MemoryPack.MemoryPackFormatterProvider.RegisterGenericType(typeof({{this.Symbol.ConstructUnboundGenericType().FullyQualifiedToString()}}), typeof({{formatterSymbol.ConstructUnboundGenericType().FullyQualifiedToString()}}));
                                      """;
        }

        string symbolFullQualified = this.ToUnionTagTypeFullyQualifiedToString(this.Symbol);
        string initializerName = this.TypeName.Replace("global::", "").Replace("<", "_").Replace(">", "_") + "Initializer";

        var code = $$"""
                     [global::MemoryPack.Internal.Preserve]
                     partial class {{this.TypeName}} : MemoryPackFormatter<{{symbolFullQualified}}>
                     {
                     {{this.EmitUnionTypeToTagField()}}

                             [global::MemoryPack.Internal.Preserve]
                             public override void {{serializeMethodSignarture}} writer, {{scopedRef}} {{symbolFullQualified}}? value)
                             {
                     {{this.OnSerializing.Select(x => "            " + x.Emit()).NewLine()}}
                     {{this.EmitUnionSerializeBody()}}
                     {{this.OnSerialized.Select(x => "            " + x.Emit()).NewLine()}}
                             }

                             [global::MemoryPack.Internal.Preserve]
                             public override void Deserialize(ref MemoryPackReader reader, {{scopedRef}} {{symbolFullQualified}}? value)
                             {
                     {{this.OnDeserializing.Select(x => "            " + x.Emit()).NewLine()}}
                     {{this.EmitUnionDeserializeBody()}}
                     {{this.OnDeserialized.Select(x => "            " + x.Emit()).NewLine()}}
                             }
                     }

                     public static class {{initializerName}}
                     {
                     #if NET5_0_OR_GREATER
                         [System.Runtime.CompilerServices.ModuleInitializer]
                     #endif
                         public static void RegisterFormatter()
                         {
                     {{registerFormatterCode}}
                         }
                     }
                     """;

        writer.AppendLine(code);
    }

    private string ToUnionTagTypeFullyQualifiedToString(INamedTypeSymbol type)
    {
        if (type.IsGenericType && this.Symbol.IsGenericType)
        {
            // when generic type, it is unconstructed.( typeof(T<>) ) so construct symbol's T
            string typeName = string.Join(", ", this.Symbol.TypeArguments.Select(x => x.FullyQualifiedToString()));
            return type.FullyQualifiedToString().Replace("<>", "<" + typeName + ">");
        }

        return type.FullyQualifiedToString();
    }

    private string EmitUnionTypeToTagField()
    {
        string elements = this.UnionTags.Select(x => $"            {{ typeof({this.ToUnionTagTypeFullyQualifiedToString(x.Type)}), {x.Tag} }},").NewLine();

        return $$"""
                         static readonly System.Collections.Generic.Dictionary<Type, ushort> __typeToTag = new({{this.UnionTags.Length}})
                         {
                 {{elements}}
                         };
                 """;
    }

    private string EmitUnionSerializeBody()
    {
        string symbolFullQualified = this.ToUnionTagTypeFullyQualifiedToString(this.Symbol);

        string writeBody = this.UnionTags
                               .Select(x =>
                               {
                                   string method = x.Type.TryGetMemoryPackableType(this.reference, out GenerateType genType, out SerializeLayout _) &&
                                                   genType is GenerateType.Object or GenerateType.VersionTolerant or GenerateType.CircularReference
                                       ? "WritePackable"
                                       : "WriteValue";
                                   return
                                       $"                    case {x.Tag}: writer.{method}(System.Runtime.CompilerServices.Unsafe.As<{symbolFullQualified}?, {this.ToUnionTagTypeFullyQualifiedToString(x.Type)}>(ref value)); break;";
                               })
                               .NewLine();

        return $$"""
                             if (value == null)
                             {
                                 writer.WriteNullUnionHeader();
                 {{this.OnSerialized.Select(x => "            " + x.Emit()).NewLine()}}
                                 return;
                             }

                             if (__typeToTag.TryGetValue(value.GetType(), out var tag))
                             {
                                 writer.WriteUnionHeader(tag);

                                 switch (tag)
                                 {
                 {{writeBody}}
                                     default:
                                         break;
                                 }
                             }
                             else
                             {
                                 MemoryPackSerializationException.ThrowNotFoundInUnionType(value.GetType(), typeof({{symbolFullQualified}}));
                             }
                 """;
    }

    private string EmitUnionDeserializeBody()
    {
        string symbolFullQualified = this.ToUnionTagTypeFullyQualifiedToString(this.Symbol);

        string readBody = this.UnionTags.Select(x =>
        {
            string tagTypeFullQualified = this.ToUnionTagTypeFullyQualifiedToString(x.Type);

            string method = x.Type.TryGetMemoryPackableType(this.reference, out GenerateType genType, out SerializeLayout _) &&
                            genType is GenerateType.Object or GenerateType.VersionTolerant or GenerateType.CircularReference
                ? "ReadPackable"
                : "ReadValue";

            string castString = method == "ReadPackable" && symbolFullQualified != tagTypeFullQualified
                ? $"({tagTypeFullQualified})"
                : "";

            return $$"""
                                     case {{x.Tag}}:
                                         if (value is {{tagTypeFullQualified}})
                                         {
                                             reader.{{method}}(ref System.Runtime.CompilerServices.Unsafe.As<{{symbolFullQualified}}?, {{tagTypeFullQualified}}>(ref value));
                                         }
                                         else
                                         {
                                             value = {{castString}}reader.{{method}}<{{tagTypeFullQualified}}>();
                                         }
                                         break;
                     """;
        }).NewLine();


        return $$"""
                             if (!reader.TryReadUnionHeader(out var tag))
                             {
                                 value = default;
                 {{this.OnDeserialized.Select(x => "                " + x.Emit()).NewLine()}}
                                 return;
                             }

                             switch (tag)
                             {
                 {{readBody}}
                                 default:
                                     MemoryPackSerializationException.ThrowInvalidTag(tag, typeof({{symbolFullQualified}}));
                                     break;
                             }
                 """;
    }

    private string EmitGenericCollectionTemplate(IGeneratorContext context)
    {
        (CollectionKind collectionKind, INamedTypeSymbol? collectionSymbol) = ParseCollectionKind(this.Symbol, this.reference);
        string methodName = collectionKind switch
        {
            CollectionKind.Collection => "Collection",
            CollectionKind.Set => "Set",
            CollectionKind.Dictionary => "Dictionary",
            var _ => ""
        };

        string typeArgs = string.Join(", ", collectionSymbol!.TypeArguments.Select(x => x.FullyQualifiedToString()));

        string staticRegisterFormatterMethod = context.IsNet7OrGreater
            ? "static void IMemoryPackFormatterRegister."
            : "public static void ";
        string register = context.IsNet7OrGreater
            ? $"global::MemoryPack.MemoryPackFormatterProvider.Register<{this.TypeName}>();"
            : "RegisterFormatter();";

        var code = $$"""
                     partial class {{this.TypeName}} : IMemoryPackFormatterRegister
                     {
                         static partial void StaticConstructor();

                         static {{this.Symbol.Name}}()
                         {
                             {{register}}
                             StaticConstructor();
                         }

                         {{staticRegisterFormatterMethod}}RegisterFormatter()
                         {
                             if (!global::MemoryPack.MemoryPackFormatterProvider.IsRegistered<{{this.TypeName}}>())
                             {
                                 global::MemoryPack.MemoryPackFormatterProvider.Register{{methodName}}<{{this.TypeName}}, {{typeArgs}}>();
                             }
                         }
                     }
                     """;

        return code;
    }
}

public partial class MethodMeta
{
    public string Emit()
    {
        string instance = this.IsStatic ? ""
            : this.IsValueType ? "value."
            : "value?.";

        if (this.UseReaderArgument)
        {
            return $"{instance}{this.Name}(ref reader, ref value);";
        }

        if (this.UseWriterArgument)
        {
            return $"{instance}{this.Name}(ref writer, ref value);";
        }

        return $"{instance}{this.Name}();";
    }
}

public partial class MemberMeta
{
    public string EmitSerialize(string writer)
    {
        switch (this.Kind)
        {
            case MemberKind.MemoryPackable:
                return $"{writer}.WritePackable(value.@{this.Name});";
            case MemberKind.Unmanaged:
            case MemberKind.Enum:
                return $"{writer}.WriteUnmanaged(value.@{this.Name});";
            case MemberKind.UnmanagedNullable:
                return $"{writer}.DangerousWriteUnmanaged(value.@{this.Name});";
            case MemberKind.String:
                return $"{writer}.WriteString(value.@{this.Name});";
            case MemberKind.UnmanagedArray:
                return $"{writer}.WriteUnmanagedArray(value.@{this.Name});";
            case MemberKind.MemoryPackableArray:
                return $"{writer}.WritePackableArray(value.@{this.Name});";
            case MemberKind.MemoryPackableList:
                return $"global::MemoryPack.Formatters.ListFormatter.SerializePackable(ref {writer}, value.@{this.Name});";
            case MemberKind.Array:
                return $"{writer}.WriteArray(value.@{this.Name});";
            case MemberKind.Blank:
                return "";
            case MemberKind.CustomFormatter:
                return $"{writer}.WriteValueWithFormatter(__{this.Name}Formatter, value.@{this.Name});";
            default:
                return $"{writer}.WriteValue(value.@{this.Name});";
        }
    }

    public string EmitVarIntLength()
    {
        switch (this.Kind)
        {
            case MemberKind.Unmanaged:
            case MemberKind.Enum:
            case MemberKind.UnmanagedNullable:
                return $"writer.WriteVarInt(System.Runtime.CompilerServices.Unsafe.SizeOf<{this.MemberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>());";
            case MemberKind.String:
                return $"writer.WriteVarInt(writer.GetStringWriteLength(value.@{this.Name}));";
            case MemberKind.UnmanagedArray:
                return
                    $"writer.WriteVarInt(writer.GetUnmanageArrayWriteLength<{(this.MemberType as IArrayTypeSymbol)!.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>(value.@{this.Name}));";
            case MemberKind.Blank:
                return "writer.WriteVarInt(0);";
            default:
                throw new InvalidOperationException("This MemberKind is not supported, Kind:" + this.Kind);
        }
    }

    public string EmitReadToDeserialize(int i, bool requireDeltaCheck)
    {
        string equalDefault = this.Kind == MemberKind.Blank
            ? "{ }"
            : $"{{ __{this.Name} = default; }}";

        string pre = requireDeltaCheck
            ? $"if (deltas[{i}] == 0) {equalDefault} else "
            : "";

        switch (this.Kind)
        {
            case MemberKind.MemoryPackable:
                return $"{pre}__{this.Name} = reader.ReadPackable<{this.MemberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();";
            case MemberKind.Unmanaged:
            case MemberKind.Enum:
                return $"{pre}reader.ReadUnmanaged(out __{this.Name});";
            case MemberKind.UnmanagedNullable:
                return $"{pre}reader.DangerousReadUnmanaged(out __{this.Name});";
            case MemberKind.String:
                return $"{pre}__{this.Name} = reader.ReadString();";
            case MemberKind.UnmanagedArray:
                return $"{pre}__{this.Name} = reader.ReadUnmanagedArray<{(this.MemberType as IArrayTypeSymbol)!.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();";
            case MemberKind.MemoryPackableArray:
                return $"{pre}__{this.Name} = reader.ReadPackableArray<{(this.MemberType as IArrayTypeSymbol)!.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();";
            case MemberKind.MemoryPackableList:
                return
                    $"{pre}__{this.Name} = global::MemoryPack.Formatters.ListFormatter.DeserializePackable<{(this.MemberType as INamedTypeSymbol)!.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>(ref reader);";
            case MemberKind.Array:
                return $"{pre}__{this.Name} = reader.ReadArray<{(this.MemberType as IArrayTypeSymbol)!.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();";
            case MemberKind.Blank:
                return $"{pre}reader.Advance(deltas[{i}]);";
            case MemberKind.CustomFormatter:
            {
                string mt = this.MemberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                return $"{pre}__{this.Name} = reader.ReadValueWithFormatter<{this.CustomFormatterName}, {mt}>(__{this.Name}Formatter);";
            }
            default:
                return $"{pre}__{this.Name} = reader.ReadValue<{this.MemberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();";
        }
    }

    public string EmitReadRefDeserialize(int i, bool requireDeltaCheck)
    {
        string pre = requireDeltaCheck
            ? $"if (deltas[{i}] != 0) "
            : "";

        switch (this.Kind)
        {
            case MemberKind.MemoryPackable:
                return $"{pre}reader.ReadPackable(ref __{this.Name});";
            case MemberKind.Unmanaged:
            case MemberKind.Enum:
                return $"{pre}reader.ReadUnmanaged(out __{this.Name});";
            case MemberKind.UnmanagedNullable:
                return $"{pre}reader.DangerousReadUnmanaged(out __{this.Name});";
            case MemberKind.String:
                return $"{pre}__{this.Name} = reader.ReadString();";
            case MemberKind.UnmanagedArray:
                return $"{pre}reader.ReadUnmanagedArray(ref __{this.Name});";
            case MemberKind.MemoryPackableArray:
                return $"{pre}reader.ReadPackableArray(ref __{this.Name});";
            case MemberKind.MemoryPackableList:
                return $"{pre}global::MemoryPack.Formatters.ListFormatter.DeserializePackable(ref reader, ref __{this.Name});";
            case MemberKind.Array:
                return $"{pre}reader.ReadArray(ref __{this.Name});";
            case MemberKind.Blank:
                return $"{pre}reader.Advance(deltas[{i}]);";
            case MemberKind.CustomFormatter:
                return $"{pre}reader.ReadValueWithFormatter(__{this.Name}Formatter, ref __{this.Name});";
            default:
                return $"{pre}reader.ReadValue(ref __{this.Name});";
        }
    }
}