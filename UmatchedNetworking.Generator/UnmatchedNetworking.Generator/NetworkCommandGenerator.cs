using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using MemoryPack.Generator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace UnmatchedNetworking.Generator;

[Generator]
public class NetworkCommandGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext ctx)
    {
        // 1. Find all types with [NetworkCommand]
        IncrementalValuesProvider<TypeToProcess> types = ctx.SyntaxProvider.ForAttributeWithMetadataName(
            "UnmatchedNetworking.Networking.NetworkCommandAttribute",
            (node, _) => node is TypeDeclarationSyntax,
            (context, _) =>
            {
                var typeSymbol = (INamedTypeSymbol)context.TargetSymbol;
                SyntaxReference syntaxRef = typeSymbol.DeclaringSyntaxReferences.First();
                var typeSyntax = (TypeDeclarationSyntax)syntaxRef.GetSyntax();

                // Get all attribute data
                AttributeData attrData = typeSymbol.GetAttributes()
                                                   .First(ad => ad.AttributeClass?.Name == "NetworkCommandAttribute");

                // Extract the GUID from attribute
                var guidValue = "";
                if (attrData.NamedArguments.FirstOrDefault(kv => kv.Key == "Id").Value is { Value: string idValue })
                    guidValue = idValue;
                else if (attrData.ConstructorArguments.FirstOrDefault(kv => kv.Value is string or Guid).Value is { } idValue1)
                    guidValue = idValue1.ToString();

                return new TypeToProcess
                {
                    TypeSymbol = typeSymbol,
                    TypeSyntax = typeSyntax,
                    GuidValue = guidValue
                };
            }
        );

        // 2. Register modified compilation provider
        // IncrementalValueProvider<(Compilation, ImmutableArray<TypeToProcess>)> compilationAndTypes = 
        //     ctx.CompilationProvider.Combine(types.Collect());

        // 3. Add MemoryPackable attribute to compilation
        // var modifiedCompilation = compilationAndTypes
        //     .Select((tuple, _) => AddMemoryPackAttributesToCompilation(tuple.Item1, tuple.Item2));

        IncrementalValueProvider<(LanguageVersion langVersion, bool net7)> parseOptions = ctx.ParseOptionsProvider
                                                                                             .Select((parseOptions, token) =>
                                                                                             {
                                                                                                 var csOptions = (CSharpParseOptions)parseOptions;
                                                                                                 LanguageVersion langVersion = csOptions.LanguageVersion;
                                                                                                 bool net7 = csOptions.PreprocessorSymbolNames.Contains("NET7_0_OR_GREATER");
                                                                                                 return (langVersion, net7);
                                                                                             })
                                                                                             .WithTrackingName("MemoryPack.MemoryPackable.0_ParseOptionsProvider");

        IncrementalValuesProvider<((TypeToProcess Left, Compilation Right) Left, (LanguageVersion langVersion, bool net7) Right)> source = types
            .Combine(ctx.CompilationProvider)
            // .WithComparer(MemoryPackGenerator.Comparer.Instance)
            .Combine(parseOptions)
            // .Combine(modifiedCompilation)
            .WithTrackingName("MemoryPack.MemoryPackable.2_MemoryPackableCombined");

        ctx.RegisterSourceOutput(source, static (context, source) =>
        {
            (TypeToProcess? typeDeclaration, Compilation? compilation) = source.Left;
            (LanguageVersion langVersion, bool net7) = source.Right;
            // var compilation = source.Right;
            MemoryPackGenerator.Generate(typeDeclaration.TypeSymbol, compilation, new MemoryPackGenerator.GeneratorContext(context, langVersion, net7));

            INamedTypeSymbol typeSym = typeDeclaration.TypeSymbol;
            TypeDeclarationSyntax decl = typeDeclaration.TypeSyntax;
            string guidValue = typeDeclaration.GuidValue;

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("#pragma warning disable CS0108 // hides inherited member");
            // sb.AppendLine("#pragma warning disable CS0162 // Unreachable code");
            // sb.AppendLine("#pragma warning disable CS0164 // This label has not been referenced");
            // sb.AppendLine("#pragma warning disable CS0219 // Variable assigned but never used");
            // sb.AppendLine("#pragma warning disable CS0618 // Type or member is obsolete");
            // sb.AppendLine("#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.");
            // sb.AppendLine("#pragma warning disable CS8601 // Possible null reference assignment"); 
            // sb.AppendLine("#pragma warning disable CS8602" );
            // sb.AppendLine("#pragma warning disable CS8604 // Possible null reference argument for parameter" );
            // sb.AppendLine("#pragma warning disable CS8619" );
            // sb.AppendLine("#pragma warning disable CS8620" );
            // sb.AppendLine("#pragma warning disable CS8631 // The type cannot be used as type parameter in the generic type or method" );
            // sb.AppendLine("#pragma warning disable CS8765 // Nullability of type of parameter" );
            // sb.AppendLine("#pragma warning disable CS9074 // The 'scoped' modifier of parameter doesn't match overridden or implemented member" );
            // sb.AppendLine("#pragma warning disable CA1050 // Declare types in namespaces.");
            sb.AppendLine("");
            sb.AppendLine("");
            sb.AppendLine("using UnmatchedNetworking.InternetProtocol;");
            sb.AppendLine("using UnmatchedNetworking.Networking;");
            sb.AppendLine("");
            sb.AppendLine("namespace " + typeSym.ContainingNamespace.ToDisplayString() + ";");

            // Prepare class/struct declaration
            string typeName = typeSym.Name;
            string fullTypeName = typeSym.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                                         .Replace("global::", "")
                                         .Replace("<", "_")
                                         .Replace(">", "_");
            string typeKeyword = decl.Kind() switch
            {
                SyntaxKind.ClassDeclaration => "class",
                SyntaxKind.StructDeclaration => "struct",
                SyntaxKind.InterfaceDeclaration => "interface",
                SyntaxKind.RecordDeclaration => "record",
                var _ => throw new InvalidOperationException($"Unsupported type kind: {decl.Kind()}")
            };

            sb.AppendLine("");
            sb.AppendLine("[global::MemoryPack.MemoryPackable]");
            sb.AppendLine($"partial {typeKeyword} {typeName} : INetworkCommand");
            sb.AppendLine("{");

            sb.AppendLine("    [global::MemoryPack.MemoryPackIgnore]");
            sb.AppendLine($"    public Guid TypeId {{ get; }} = Guid.Parse(\"{guidValue}\");");

            sb.AppendLine("");
            sb.AppendLine("    public Guid InstanceId { get; } = Guid.NewGuid();");
            sb.AppendLine("");
            sb.AppendLine("    [global::MemoryPack.MemoryPackIgnore]");
            sb.AppendLine("    private byte[] _data = [];");
            sb.AppendLine("");
            sb.AppendLine("    [global::MemoryPack.MemoryPackIgnore]");
            sb.AppendLine("    public ReadOnlySpan<byte> Data => _data;");
            sb.AppendLine("}");

            context.AddSource($"{fullTypeName}.NetworkCommand.g.cs", sb.ToString());
        });
    }

    private Compilation AddMemoryPackAttributesToCompilation(
        Compilation compilation,
        ImmutableArray<TypeToProcess> typesToProcess)
    {
        // Create a new compilation for each updated tree
        Compilation currentCompilation = compilation;

        foreach (TypeToProcess? typeToProcess in typesToProcess)
        {
            SyntaxTree syntaxTree = typeToProcess.TypeSyntax.SyntaxTree;
            SyntaxNode root = syntaxTree.GetRoot();

            // Find the node in this tree
            TypeDeclarationSyntax? typeNode = root.DescendantNodes()
                                                  .OfType<TypeDeclarationSyntax>()
                                                  .FirstOrDefault(n => n == typeToProcess.TypeSyntax);

            if (typeNode != null)
            {
                // Create the MemoryPackable attribute
                AttributeListSyntax attributeList = SyntaxFactory.AttributeList(
                    SyntaxFactory.SingletonSeparatedList(
                        SyntaxFactory.Attribute(
                            SyntaxFactory.ParseName("global::MemoryPack.MemoryPackable"))));

                // Add the attribute to the type declaration
                TypeDeclarationSyntax newTypeNode = typeNode.AddAttributeLists(attributeList);

                // Replace in the syntax tree
                SyntaxNode newRoot = root.ReplaceNode(typeNode, newTypeNode);
                SyntaxTree newTree = syntaxTree.WithRootAndOptions(newRoot, syntaxTree.Options);

                // Update the compilation with the new tree
                currentCompilation = currentCompilation.ReplaceSyntaxTree(syntaxTree, newTree);
            }
        }

        return currentCompilation;
    }
}

// Simple class to carry the data we need between pipeline steps
public class TypeToProcess
{
    public INamedTypeSymbol TypeSymbol { get; set; }
    public TypeDeclarationSyntax TypeSyntax { get; set; }
    public string GuidValue { get; set; }
}