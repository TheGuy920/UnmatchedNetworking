using System;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace UnmatchedNetworking.Generator;

[Generator]
public class NetworkCommandHandlerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext ctx)
    {
        // 1. Find all types with [NetworkingCommandHandler<T>]
        IncrementalValuesProvider<INamedTypeSymbol> types = ctx.SyntaxProvider.ForAttributeWithMetadataName(
            "UnmatchedNetworking.InternetProtocol.NetworkingCommandHandlerAttribute`1",
            (node, _) => node is TypeDeclarationSyntax,
            (context, _) => (INamedTypeSymbol)context.TargetSymbol
        );

        // 2. Generate code for each
        ctx.RegisterSourceOutput(types, (spc, typeSym) =>
        {
            // Get the first declaration syntax for the type
            SyntaxReference syntaxRef = typeSym.DeclaringSyntaxReferences.First();
            var decl = (TypeDeclarationSyntax)syntaxRef.GetSyntax();

            // Find the attribute and extract the generic type parameter (T)
            AttributeData attrData = typeSym.GetAttributes()
                                            .First(ad => ad.AttributeClass?.ToDisplayString().StartsWith(
                                                "UnmatchedNetworking.InternetProtocol.NetworkingCommandHandlerAttribute<") == true);

            // Extract the generic type parameter (T) from the attribute
            ITypeSymbol genericType = attrData.AttributeClass?.TypeArguments.First()!;
            AttributeData genericTypeAttributes = genericType.GetAttributes().First(a => a.AttributeClass?.Name == "NetworkCommandAttribute");
            TypedConstant[] genericTypeArgs = [..genericTypeAttributes.ConstructorArguments, ..genericTypeAttributes.NamedArguments.Select(kvp => kvp.Value)];
            object? argValue = genericTypeArgs.First(arg => arg.Value is string or Guid).Value;
            string genericTypeStr = genericType.ToDisplayString();
            if (string.IsNullOrEmpty(genericTypeStr))
            {
                // Could not extract the generic type
                return;
            }

            // Prepare class/struct declaration
            string typeName = typeSym.Name;
            string fullTypeName = typeSym.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                                         .Replace("global::", "")
                                         .Replace("<", "_")
                                         .Replace(">", "_");
            string namespaceText = typeSym.ContainingNamespace.ToDisplayString();
            string typeKeyword = decl.Kind() switch
            {
                SyntaxKind.ClassDeclaration => "class",
                SyntaxKind.StructDeclaration => "struct",
                SyntaxKind.InterfaceDeclaration => "interface",
                SyntaxKind.RecordDeclaration => "record",
                var _ => throw new InvalidOperationException($"Unsupported type kind: {decl.Kind()}")
            };

            // Build the source code
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("#pragma warning disable CS0108 // hides inherited member");
            // sb.AppendLine("#pragma warning disable CS0162 // Unreachable code");
            // sb.AppendLine("#pragma warning disable CS0164 // This label has not been referenced");
            // sb.AppendLine("#pragma warning disable CS0219 // Variable assigned but never used");
            // sb.AppendLine("#pragma warning disable CS0618 // Type or member is obsolete");
            // sb.AppendLine("#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.");
            // sb.AppendLine("#pragma warning disable CS8601 // Possible null reference assignment"); 
            // sb.AppendLine("#pragma warning disable CS8602" );
            // sb.AppendLine("#pragma warning disable CS8604 // Possible null reference argument for parameter" );
            // sb.AppendLine("#pragma warning disable CS8619" );
            // sb.AppendLine("#pragma warning disable CS8620" );
            // sb.AppendLine("#pragma warning disable CS8631 // The type cannot be used as type parameter in the generic type or method" );
            // sb.AppendLine("#pragma warning disable CS8765 // Nullability of type of parameter" );
            // sb.AppendLine("#pragma warning disable CS9074 // The 'scoped' modifier of parameter doesn't match overridden or implemented member" );
            // sb.AppendLine("#pragma warning disable CA1050 // Declare types in namespaces.");
            sb.AppendLine("");
            sb.AppendLine("using UnmatchedNetworking.Networking;");
            sb.AppendLine("using UnmatchedNetworking.InternetProtocol;");
            sb.AppendLine("using UnmatchedNetworking.InternetProtocol.Data;");
            sb.AppendLine("");
            sb.AppendLine($"namespace {namespaceText};");

            // Generate the partial class/struct with the right inheritance
            sb.AppendLine("");
            sb.AppendLine("[global::JetBrains.Annotations.UsedImplicitly]");
            sb.AppendLine($"partial {typeKeyword} {typeName} : NetworkingCommandHandler<{genericTypeStr}>");
            sb.AppendLine("{");

            // Implement the Process(INetworkPacket) method
            sb.AppendLine($"    public override Guid TypeId {{ get; }} = Guid.Parse(\"{argValue}\");");
            sb.AppendLine("    public override void Process(NetworkUserId sender, INetworkPacket data)");
            sb.AppendLine("    {");
            sb.AppendLine($"        {genericTypeStr}? instance = NetworkCommand.Deserialize<{genericTypeStr}>(data.Data);");
            sb.AppendLine("        this.Process(sender, instance);");
            sb.AppendLine("    }");

            sb.AppendLine("}");

            // Add the source file
            spc.AddSource($"{fullTypeName}.NetworkCommand.g.cs", sb.ToString());
        });
    }
}